"use strict";
var joi = require("joi");
var _a = require("lodash"), find = _a.find, get = _a.get, isEqual = _a.isEqual, isNumber = _a.isNumber, isPlainObject = _a.isPlainObject, isString = _a.isString, merge = _a.merge, set = _a.set, uniqWith = _a.uniqWith;
var patterns = {
    alphanum: "^[a-zA-Z0-9]*$",
    alphanumLower: "^[a-z0-9]*$",
    alphanumUpper: "^[A-Z0-9]*$",
    token: "^[a-zA-Z0-9_]*$"
};
function meta(schema, key) {
    var flattened = Object.assign.apply(null, [{}].concat(schema.$_terms.metas));
    return get(flattened, key);
}
/*function refDef (type, name) {
    return { $ref: '#/components/' + type + '/' + name };
}*/
function getMinMax(schema, suffix) {
    if (suffix === void 0) { suffix = "Length"; }
    var swagger = {};
    for (var i = 0; i < schema._rules.length; i++) {
        var test_1 = schema._rules[i];
        if (test_1.name === "min") {
            swagger["min" + suffix] = test_1.args.limit;
        }
        if (test_1.name === "max") {
            swagger["max" + suffix] = test_1.args.limit;
        }
        /*if (test.name === 'length') {
                swagger[`min${suffix}`] = test.args.limit;
                swagger[`max${suffix}`] = test.args.limit;
            }*/
    }
    return swagger;
}
/*function getCaseSuffix (schema) {
    const caseRule = find(schema._rules, { name: 'case' });
    if (caseRule && caseRule.args.direction === 'lower') {
        return 'Lower';
    } else if (caseRule && caseRule.args.direction === 'upper') {
        return 'Upper';
    }
    return '';
}*/
/*function parseWhens (schema, existingComponents, newComponentsByRef) {
    const whens = get(schema, '$_terms.whens');
    const mode = whens.length > 1 ? 'anyOf' : 'oneOf';

    const alternatives = [];
    for (const w of whens) {
        if (w.then) alternatives.push(w.then);
        if (w.otherwise) alternatives.push(w.otherwise);
        if (w.switch) {
            for (const s of w.switch) {
                if (s.then) alternatives.push(s.then);
                if (s.otherwise) alternatives.push(s.otherwise);
            }
        }
    }

    return schemaForAlternatives(alternatives, existingComponents, newComponentsByRef, mode);
}*/
/*function schemaForAlternatives (alternatives, existingComponents, newComponentsByRef, mode) {
    let swaggers = [];
    for (const joiSchema of alternatives) {
        const { swagger, components } = parse(joiSchema, merge({}, existingComponents || {}, newComponentsByRef || {}));
        if (!swagger) continue; // swagger is falsy if joi.forbidden()
        if (get(joiSchema, '_flags.presence') === 'required') {
            swagger['x-required'] = true;
        }
        merge(newComponentsByRef, components || {});

        swaggers.push(swagger);
    }
    swaggers = uniqWith(swaggers, isEqual);

    return swaggers.length > 0 ? { [mode]: swaggers } : {};
}*/
function parseValidsAndInvalids(schema, filterFunc) {
    var swagger = {};
    if (schema._valids) {
        var valids = schema._valids.values().filter(filterFunc);
        if (get(schema, "_flags.only") && valids.length) {
            swagger.enum = valids;
        }
    }
    /*if (schema._invalids) {
          const invalids = schema._invalids.values().filter(filterFunc);
          if (invalids.length) {
              swagger.not = { enum: invalids };
          }
      }*/
    return swagger;
}
var parseAsType = {
    number: function (schema) {
        var swagger = {};
        if (find(schema._rules, { name: "integer" })) {
            swagger.type = "integer";
        }
        else {
            swagger.type = "number";
            //if (find(schema._rules, { name: 'precision' })) {
            //	swagger.format = 'double';
            //} else {
            swagger.format = "float";
            //}
        }
        var sign = find(schema._rules, { name: "sign" });
        /*if (sign) {
                if (sign.args.sign === 'positive') {
                    swagger.minimum = 1;
                } else if (sign.args.sign === 'negative') {
                    swagger.maximum = -1;
                }
            }*/
        var min = find(schema._rules, { name: "min" });
        if (min) {
            swagger.minimum = min.args.limit;
        }
        var max = find(schema._rules, { name: "max" });
        if (max) {
            swagger.maximum = max.args.limit;
        }
        Object.assign(swagger, parseValidsAndInvalids(schema, function (s) { return isNumber(s); }));
        return swagger;
    },
    string: function (schema) {
        var swagger = { type: "string" };
        /*if (find(schema._rules, { name: 'alphanum' })) {
                const strict = get(schema, '_preferences.convert') === false;
                swagger.pattern = patterns[`alphanum${strict ? getCaseSuffix(schema) : ''}`];
            }*/
        /*if (find(schema._rules, { name: 'token' })) {
                swagger.pattern = patterns.token;
            }*/
        if (find(schema._rules, { name: "email" })) {
            swagger.format = "email";
            if (swagger.pattern)
                delete swagger.pattern;
        }
        if (find(schema._rules, { name: "isoDate" })) {
            swagger.format = "date-time";
            if (swagger.pattern)
                delete swagger.pattern;
        }
        /*if (find(schema._rules, { name: 'guid' })) {
                swagger.format = 'uuid';
                if (swagger.pattern) delete swagger.pattern;
            }*/
        /*const pattern = find(schema._rules, { name: 'pattern' });
            if (pattern) {
                swagger.pattern = pattern.args.regex.toString().slice(1, -1);
            }*/
        Object.assign(swagger, getMinMax(schema));
        Object.assign(swagger, parseValidsAndInvalids(schema, function (s) { return isString(s); }));
        return swagger;
    },
    binary: function (schema) {
        var swagger = { type: "string", format: "binary" };
        if (get(schema, "_flags.encoding") === "base64") {
            swagger.format = "byte";
        }
        Object.assign(swagger, getMinMax(schema));
        return swagger;
    },
    //	date: (/* schema */) => ({ type: 'string', format: 'date-time' }),
    boolean: function ( /* schema */) { return ({ type: "boolean" }); },
    /*alternatives: (schema, existingComponents, newComponentsByRef) => {
          const matches = get(schema, '$_terms.matches');
          const mode = `${get(schema, '_flags.match') || 'any'}Of`;
  
          const alternatives = [];
          for (const m of matches) {
              if (m.ref) {
                  if (m.then) alternatives.push(m.then);
                  if (m.otherwise) alternatives.push(m.otherwise);
                  if (m.switch) {
                      for (const s of m.switch) {
                          if (s.then) alternatives.push(s.then);
                          if (s.otherwise) alternatives.push(s.otherwise);
                      }
                  }
              } else {
                  alternatives.push(m.schema);
              }
          }
  
          return schemaForAlternatives(alternatives, existingComponents, newComponentsByRef, mode);
      },*/
    array: function (schema, existingComponents, newComponentsByRef) {
        var _a;
        var items = get(schema, "$_terms.items");
        var mode = "oneOf";
        var alternatives = items;
        var swaggers = [];
        for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {
            var joiSchema = alternatives_1[_i];
            var _b = parse(joiSchema, merge({}, existingComponents || {}, newComponentsByRef || {})), swagger = _b.swagger, components = _b.components;
            if (!swagger)
                continue; // swagger is falsy if joi.forbidden()
            merge(newComponentsByRef, components || {});
            swaggers.push(swagger);
        }
        swaggers = uniqWith(swaggers, isEqual);
        var openapi = {
            type: "array",
            items: (_a = {}, _a[mode] = swaggers, _a)
        };
        if (swaggers.length <= 1) {
            openapi.items = get(swaggers, [0]) || {};
        }
        Object.assign(openapi, getMinMax(schema, "Items"));
        /*if (find(schema._rules, { name: 'unique' })) {
                openapi.uniqueItems = true;
            }*/
        return openapi;
    },
    object: function (schema, existingComponents, newComponentsByRef) {
        var requireds = [];
        var properties = {};
        var combinedComponents = merge({}, existingComponents || {}, newComponentsByRef || {});
        var children = get(schema, "$_terms.keys") || [];
        children.forEach(function (child) {
            var key = child.key;
            var _a = parse(child.schema, combinedComponents), parsedSwagger = _a.swagger, components = _a.components;
            /*if (!swagger) { // swagger is falsy if joi.forbidden()
                      return;
                  }*/
            merge(newComponentsByRef, components || {});
            merge(combinedComponents, components || {});
            properties[key] = parsedSwagger;
            if (get(child, "schema._flags.presence") === "required") {
                requireds.push(key);
            }
        });
        var swagger = {
            type: "object",
            properties: properties
        };
        if (requireds.length) {
            swagger.required = requireds;
        }
        /*if (get(schema, '_flags.unknown') !== true) {
                swagger.additionalProperties = false;
            }*/
        return swagger;
    }
    /*	any: (schema) => {
          const swagger = {};
          // convert property to file upload, if indicated by meta property
          if (meta(schema, 'swaggerType') === 'file') {
              swagger.type = 'file';
              swagger.in = 'formData';
          }
  
          Object.assign(swagger, parseValidsAndInvalids(schema, (s) => isString(s) || isNumber(s)));
  
          return swagger;
      },*/
};
function parse(schema, existingComponents) {
    // inspect(schema);
    if (!schema)
        throw new Error("No schema was passed.");
    /*if (isPlainObject(schema)) {
          schema = joi.object().keys(schema);
      }*/
    if (!joi.isSchema(schema))
        throw new TypeError("Passed schema does not appear to be a joi schema.");
    var flattenMeta = Object.assign.apply(null, [{}].concat(schema.$_terms.metas));
    /*const override = flattenMeta.swagger;
      if (override && flattenMeta.swaggerOverride) {
          return { swagger: override, components: {} };
      }*/
    var metaDefName = flattenMeta.className;
    var metaDefType = flattenMeta.classTarget || "schemas";
    // if the schema has a definition class name, and that
    // definition is already defined, just use that definition
    /*if (metaDefName && get(existingComponents, [ metaDefType, metaDefName ])) {
          return { swagger: refDef(metaDefType, metaDefName) };
      }*/
    /*if (get(schema, '_flags.presence') === 'forbidden') {
          return false;
      }*/
    var type = meta(schema, "baseType") || schema.type;
    /*if (!parseAsType[type]) {
          throw new TypeError(`${type} is not a recognized Joi type.`);
      }*/
    var components = {};
    var swagger = parseAsType[type](schema, existingComponents, components);
    //if(flattenMeta) {
    Object.assign(swagger, { meta: flattenMeta });
    //}
    /*if (get(schema, '$_terms.whens')) {
          Object.assign(swagger, parseWhens(schema, existingComponents, components));
      }*/
    //if (!swagger) return { swagger, components };
    if (schema._valids && schema._valids.has(null)) {
        swagger.nullable = true;
    }
    var description = get(schema, "_flags.description");
    if (description) {
        swagger.description = description;
    }
    if (schema.$_terms.examples) {
        //if (schema.$_terms.examples.length === 1) {
        swagger.example = schema.$_terms.examples[0];
        /*} else {
                swagger.examples = schema.$_terms.examples;
            }*/
    }
    /*const label = get(schema, '_flags.label');
      if (label) {
          swagger.title = label;
      }*/
    var defaultValue = get(schema, "_flags.default");
    if ((defaultValue ||
        typeof defaultValue === "boolean" ||
        typeof defaultValue === "number") &&
        typeof defaultValue !== "function") {
        swagger.default = defaultValue;
    }
    /*	if (metaDefName) {
          set(components, [ metaDefType, metaDefName ], swagger);
          return { swagger: refDef(metaDefType, metaDefName), components };
      }*/
    /*if (override) {
          Object.assign(swagger, override);
      }*/
    return { swagger: swagger, components: components };
}
module.exports = exports = parse;
exports.default = parse;
//# sourceMappingURL=index.js.map